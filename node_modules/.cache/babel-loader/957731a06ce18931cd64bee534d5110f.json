{"ast":null,"code":"import { BOARD_CLICK, RESTART, SET_GAME_TYPE, SWITCH_TURNS } from \"../actions/constants\";\nimport { SIZE_TEN } from \"../components/constants\";\n\nfunction initialStateFunc() {\n  const initialState = {\n    freePlay: false,\n    user_board: buildBoard(),\n    ai_board: buildBoard(),\n    aiPlayed: true\n  };\n  return initialState;\n}\n\nfunction buildBoard() {\n  let arr = [];\n\n  for (let i = 0; i < 10; i++) {\n    arr.push(buildinitialRows());\n  }\n\n  arr = putShipsOnBoard(arr);\n  return arr;\n}\n\nfunction buildinitialRows() {\n  let row = [];\n\n  for (let i = 0; i < 10; i++) {\n    row.push(buildSquare());\n  }\n\n  return row;\n}\n\nfunction buildSquare() {\n  let squareState = {\n    hit: false,\n    miss: false,\n    isBoat: false,\n    unselected: true\n  };\n  return squareState;\n} //   console.log(initialState.player_zero.ships)\n//   console.log(initialState.player_one.ships)\n\n\nfunction putShipsOnBoard(board) {\n  for (let ship in ships) {\n    board = placeOneShip(ship, ships[ship], board);\n  }\n\n  return board;\n} // Helper function to place one ship on board\n\n\nfunction placeOneShip(shipType, shipSize, board) {\n  let isVertical = getRandomInteger(2);\n  let newRowCol = getRowAndCol(shipSize, isVertical);\n  let randomRow = newRowCol[0];\n  let randomCol = newRowCol[1]; // fillShip(randomRow, randomCol, shipSize, isVertical, board);\n\n  while (!shipPlacementValid(randomRow, randomCol, shipSize, isVertical, board)) {\n    newRowCol = getRowAndCol(shipSize, isVertical);\n    randomRow = newRowCol[0];\n    randomCol = newRowCol[1];\n  }\n\n  board = fillShip(randomRow, randomCol, shipSize, isVertical, board);\n  return board;\n} // Validates whether the ship overlaps an existing ship in the given player's\n// ship attribute\n\n\nfunction shipPlacementValid(row, col, length, isVertical, board) {\n  // check each ship\n  let currRow = row;\n  let currCol = col;\n\n  for (let i = 0; i < length; i++) {\n    if (isVertical) {\n      if (board[col][currRow].isBoat) {\n        return false;\n      }\n\n      currRow++;\n    } else {\n      if (board[currCol][row].isBoat) {\n        return false;\n      }\n\n      currCol++;\n    }\n  }\n\n  return true;\n} // Adds the row/col of each ship to the given player's ships attribute\n\n\nfunction fillShip(row, col, length, fillVertical, board) {\n  let currRow = row;\n  let currCol = col;\n\n  for (let i = 0; i < length; i++) {\n    if (fillVertical) {\n      board[col][currRow].isBoat = true;\n      currRow++;\n    } else {\n      board[currCol][row].isBoat = true;\n      currCol++;\n    }\n  }\n\n  return board;\n} //   // Helper function checking whether a ship can be placed\n//   // on given location with specified ship length\n//   // function shipPlacementValid(row, col, ship, length, player_no, isVertical) {\n//   //   console.log(\"Validate\", ship, \"player:\", player_no.ships, isVertical)\n//   //   if (ship in player_no.ships) {\n//   //     if (isVertical) {\n//   //       for (let currRow = row; currRow <= length; currRow++) {\n//   //         debugger\n//   //         for (let i=0; i < player_no.ships[ship].length; i++) {\n//   //           let testShip = player_no.ships[ship][i]\n//   //           if (testShip.x_coord === currRow && testShip.y_coord === col) {\n//   //             console.log(\"return false\")\n//   //             return false;\n//   //           }\n//   //         }\n//   //         // if (player_no.ships[ship].find(obj => obj.y_coord === currRow && obj.x_coord === col)) {\n//   //         // // if(player_no.ships[ship].indexOf({currRow, col}) >=0) {\n//   //         //   console.log(\"return false\")\n//   //         //   return false;\n//   //         // }\n//   //       }\n//   //     } else {\n//   //       for (let currCol = col; currCol <= length; currCol++) {\n//   //         for (let testShip of player_no.ships[ship]) {\n//   //           if (testShip.x_coord === row && testShip.y_coord === currCol) {\n//   //             console.log(\"return false\")\n//   //             return false;\n//   //           }\n//   //         }\n//   //         // if(player_no.ships[ship].find(obj => obj.y_coord === row && obj.x_coord === currCol)) {\n//   //         //   console.log(\"return false\")\n//   //         //   return false;\n//   //         // }\n//   //       }\n//   //     }\n//   //   }\n//   //   console.log(\"return true\")\n//   //   return true;\n//   // }\n// Helper function to get random row and column values\n\n\nfunction getRowAndCol(shipSize, isVertical) {\n  let rowMax = SIZE_TEN;\n  let colMax = SIZE_TEN;\n\n  if (isVertical) {\n    rowMax = 9 - shipSize;\n  } else {\n    colMax = 9 - shipSize;\n  }\n\n  let randomRow = getRandomInteger(rowMax);\n  let randomCol = getRandomInteger(colMax);\n  return [randomRow, randomCol];\n} // Helper function that returns a random integer between\n// 0 (inclusive) and a given maxInt (exclusive)\n\n\nfunction getRandomInteger(maxInt) {\n  return Math.floor(Math.random() * maxInt);\n} //   console.log(initialState);\n//   return initialState;\n// }\n//define a dictionary of ships with respective lengths. \n\n\nconst ships = {\n  carrier: 5,\n  battleship: 4,\n  destroyer: 3,\n  submarine: 3,\n  patrolBoat: 2\n}; // // REDUCER STARTS HERE\n\nexport const BoardReducer = (state, action) => {\n  if (state === undefined) {\n    return initialStateFunc();\n  } //   let player_no;\n  //   let opponent_player;\n  //   //if board is clicked,\n  //   if (action.type === BOARD_CLICK){\n  //     //get the current player\n  //     if(action.payload.player_id === '0'){\n  //       player_no = state.player_one;\n  //       //get the opponent player since their state/squares need to be changed\n  //       opponent_player = state.player_zero;\n  //     }else{\n  //       player_no = state.player_zero;\n  //       opponent_player = state.player_one;\n  //     }\n  //     //avoid already clicked squares being added to the list of visited squares\n  //     //change this later\n  //     if(!opponent_player.clickedSquares.some(\n  //       (e) =>\n  //         e.x_coord === action.payload.x_coord &&\n  //         e.y_coord === action.payload.y_coord\n  //     )){\n  //     if(action.payload.player_id === '0'){\n  //       //if player is player_zero, need to update the clicked squares of player one\n  //       // and the score of player_zero if a shit has been hit\n  //       return {\n  //           ...state,\n  //           player_zero:{\n  //             ...state.player_zero,\n  //             clickedSquares : state.player_zero.clickedSquares.concat(\n  //               {\n  //                 x_coord: action.payload.x_coord,\n  //                 y_coord: action.payload.y_coord,\n  //               }\n  //             ),\n  //             score: action.payload.hitShip ? state.player_zero.score - 1 :  state.player_zero.score,\n  //           },\n  //           //when clicked on board 0, set ai played to true to enable state changes for respective square\n  //           player_one : {\n  //             ...state.player_one,\n  //             aiPlayed: true\n  //           }\n  //         }\n  //     }else{\n  //         return {\n  //         ...state,\n  //         player_one:{\n  //           ...state.player_one,\n  //           clickedSquares : state.player_one.clickedSquares.concat(\n  //             {\n  //               x_coord: action.payload.x_coord,\n  //               y_coord: action.payload.y_coord,\n  //             }\n  //           ),\n  //           score: action.payload.hitShip ? state.player_one.score - 1 :  state.player_one.score\n  //         }\n  //       }\n  //     }\n  //   }\n  // }\n  //   if (action.type === RESTART) {\n  //     //fetch the previous game type and set it\n  //     let previousGameType = state.gameType.freePlay;\n  //    let newState =  initialStateFunc();\n  //    return {\n  //     ...newState,\n  //     gameType: {\n  //       ...newState.gameType,\n  //       freePlay: previousGameType\n  //     }\n  //   }\n  //   }\n\n\n  if (action.type === BOARD_CLICK) {\n    let board;\n\n    if (action.payload.enemy) {\n      board = state.ai_board;\n    } else {\n      board = state.user_board;\n    }\n\n    let boardCopy = board.map(function (arr) {\n      return arr.slice();\n    });\n    let squareCopy = { ...boardCopy[action.payload.row][action.payload.col]\n    };\n    squareCopy.hit = action.payload.hit;\n    squareCopy.miss = action.payload.miss;\n    squareCopy.unselected = action.payload.unselected;\n    boardCopy[action.payload.row][action.payload.col] = squareCopy;\n\n    if (action.payload.enemy) {\n      return { ...state,\n        ai_board: boardCopy,\n        aiPlayed: false\n      };\n    } else {\n      return { ...state,\n        user_board: boardCopy,\n        aiPlayed: true\n      };\n    }\n  }\n\n  if (action.type === SET_GAME_TYPE) {\n    return { ...state,\n      freePlay: action.payload.gameType === \"normal\" ? false : true,\n      user_board: buildBoard(),\n      ai_board: buildBoard(),\n      aiPlayed: true\n    };\n  }\n\n  if (action.type === RESTART) {\n    let newUserBoard = [];\n    let newAIBoard = [];\n    newUserBoard = buildBoard();\n    newAIBoard = buildBoard();\n    return { ...state,\n      freePlay: action.payload.isFreePlay,\n      user_board: newUserBoard,\n      ai_board: newAIBoard\n    };\n  }\n\n  return state;\n};\n_c = BoardReducer;\n\nvar _c;\n\n$RefreshReg$(_c, \"BoardReducer\");","map":{"version":3,"sources":["/Users/bomendez/Documents/CS5610/bo-mendez-srutikeerti-munukutla-pm2/src/reducers/board.js"],"names":["BOARD_CLICK","RESTART","SET_GAME_TYPE","SWITCH_TURNS","SIZE_TEN","initialStateFunc","initialState","freePlay","user_board","buildBoard","ai_board","aiPlayed","arr","i","push","buildinitialRows","putShipsOnBoard","row","buildSquare","squareState","hit","miss","isBoat","unselected","board","ship","ships","placeOneShip","shipType","shipSize","isVertical","getRandomInteger","newRowCol","getRowAndCol","randomRow","randomCol","shipPlacementValid","fillShip","col","length","currRow","currCol","fillVertical","rowMax","colMax","maxInt","Math","floor","random","carrier","battleship","destroyer","submarine","patrolBoat","BoardReducer","state","action","undefined","type","payload","enemy","boardCopy","map","slice","squareCopy","gameType","newUserBoard","newAIBoard","isFreePlay"],"mappings":"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","sourcesContent":["import { BOARD_CLICK, RESTART, SET_GAME_TYPE, SWITCH_TURNS } from \"../actions/constants\";\nimport { SIZE_TEN } from \"../components/constants\";\n\nfunction initialStateFunc() {\n\n  const initialState = {\n  freePlay: false,\n  user_board: buildBoard(),\n  ai_board: buildBoard(),\n  aiPlayed: true\n  }\n  return initialState\n \n}\n\n  \nfunction buildBoard(){\n  let arr = []\n  for(let i=0; i < 10; i++){\n    arr.push(buildinitialRows())\n  }\n  arr = putShipsOnBoard(arr)\n  return arr\n}\n\nfunction buildinitialRows(){\n  let row = []\n  for(let i=0; i< 10; i++){\n    row.push(buildSquare());\n  }\n  return row;\n}\n\n\nfunction buildSquare(){\n    let squareState = {\n      hit:false,\n      miss: false,\n      isBoat: false,\n      unselected: true\n    }\n  return squareState;\n}\n\n\n//   console.log(initialState.player_zero.ships)\n//   console.log(initialState.player_one.ships)\n\nfunction putShipsOnBoard(board) {\n  for(let ship in ships){\n    board = placeOneShip(ship, ships[ship], board);\n  }\n  return board;\n}\n\n// Helper function to place one ship on board\nfunction placeOneShip(shipType, shipSize, board) {\n  let isVertical = getRandomInteger(2);\n\n  let newRowCol = getRowAndCol(shipSize, isVertical);\n  let randomRow = newRowCol[0];\n  let randomCol = newRowCol[1];\n  // fillShip(randomRow, randomCol, shipSize, isVertical, board);\n  while (!shipPlacementValid(randomRow, randomCol, shipSize, isVertical, board)) {\n    newRowCol = getRowAndCol(shipSize, isVertical);\n    randomRow = newRowCol[0];\n    randomCol = newRowCol[1];\n  }\n  board = fillShip(randomRow, randomCol, shipSize, isVertical, board);\n  return board;\n}\n\n// Validates whether the ship overlaps an existing ship in the given player's\n// ship attribute\nfunction shipPlacementValid(row, col, length, isVertical, board) {\n  // check each ship\n  let currRow = row;\n  let currCol = col;\n  for (let i = 0; i < length; i++) {\n    if (isVertical) {\n      if (board[col][currRow].isBoat) {\n        return false;\n      }\n      currRow++;\n    } else {\n      if (board[currCol][row].isBoat) {\n        return false;\n      }\n      currCol++;\n    }\n  }\n  return true;\n}\n// Adds the row/col of each ship to the given player's ships attribute\nfunction fillShip(row, col, length, fillVertical, board) {\n  let currRow = row;\n  let currCol = col;\n  for (let i = 0; i < length; i++) {\n    if (fillVertical) {\n      board[col][currRow].isBoat = true;\n      currRow++;\n    } else {\n      board[currCol][row].isBoat = true;\n      currCol++;\n    }\n  }\n  return board;\n}\n\n//   // Helper function checking whether a ship can be placed\n//   // on given location with specified ship length\n//   // function shipPlacementValid(row, col, ship, length, player_no, isVertical) {\n//   //   console.log(\"Validate\", ship, \"player:\", player_no.ships, isVertical)\n//   //   if (ship in player_no.ships) {\n//   //     if (isVertical) {\n//   //       for (let currRow = row; currRow <= length; currRow++) {\n//   //         debugger\n//   //         for (let i=0; i < player_no.ships[ship].length; i++) {\n//   //           let testShip = player_no.ships[ship][i]\n//   //           if (testShip.x_coord === currRow && testShip.y_coord === col) {\n//   //             console.log(\"return false\")\n//   //             return false;\n//   //           }\n//   //         }\n\n//   //         // if (player_no.ships[ship].find(obj => obj.y_coord === currRow && obj.x_coord === col)) {\n//   //         // // if(player_no.ships[ship].indexOf({currRow, col}) >=0) {\n//   //         //   console.log(\"return false\")\n//   //         //   return false;\n//   //         // }\n//   //       }\n//   //     } else {\n        \n//   //       for (let currCol = col; currCol <= length; currCol++) {\n//   //         for (let testShip of player_no.ships[ship]) {\n//   //           if (testShip.x_coord === row && testShip.y_coord === currCol) {\n//   //             console.log(\"return false\")\n//   //             return false;\n//   //           }\n//   //         }\n\n//   //         // if(player_no.ships[ship].find(obj => obj.y_coord === row && obj.x_coord === currCol)) {\n//   //         //   console.log(\"return false\")\n//   //         //   return false;\n//   //         // }\n//   //       }\n//   //     }\n//   //   }\n//   //   console.log(\"return true\")\n//   //   return true;\n//   // }\n\n  // Helper function to get random row and column values\n  function getRowAndCol(shipSize, isVertical) {\n    let rowMax = SIZE_TEN;\n    let colMax = SIZE_TEN;\n    if (isVertical) {\n      rowMax = 9 - shipSize;\n    } else {\n      colMax = 9 - shipSize;\n    }\n    let randomRow = getRandomInteger(rowMax);\n    let randomCol = getRandomInteger(colMax);\n    return [randomRow, randomCol];\n  }\n\n  // Helper function that returns a random integer between\n  // 0 (inclusive) and a given maxInt (exclusive)\n  function getRandomInteger(maxInt) {\n    return Math.floor(Math.random() * maxInt);\n  }\n\n\n//   console.log(initialState);\n//   return initialState;\n// }\n\n//define a dictionary of ships with respective lengths. \nconst ships = {\n  carrier: 5,\n  battleship: 4,\n  destroyer: 3,\n  submarine: 3,\n  patrolBoat: 2\n}\n\n  \n// // REDUCER STARTS HERE\nexport const BoardReducer = (state, action) => {\n  if (state === undefined) {\n    return initialStateFunc();\n  }\n//   let player_no;\n//   let opponent_player;\n//   //if board is clicked,\n//   if (action.type === BOARD_CLICK){\n//     //get the current player\n//     if(action.payload.player_id === '0'){\n//       player_no = state.player_one;\n//       //get the opponent player since their state/squares need to be changed\n//       opponent_player = state.player_zero;\n//     }else{\n//       player_no = state.player_zero;\n//       opponent_player = state.player_one;\n//     }\n//     //avoid already clicked squares being added to the list of visited squares\n//     //change this later\n//     if(!opponent_player.clickedSquares.some(\n//       (e) =>\n//         e.x_coord === action.payload.x_coord &&\n//         e.y_coord === action.payload.y_coord\n//     )){\n//     if(action.payload.player_id === '0'){\n//       //if player is player_zero, need to update the clicked squares of player one\n//       // and the score of player_zero if a shit has been hit\n//       return {\n//           ...state,\n//           player_zero:{\n//             ...state.player_zero,\n//             clickedSquares : state.player_zero.clickedSquares.concat(\n//               {\n//                 x_coord: action.payload.x_coord,\n//                 y_coord: action.payload.y_coord,\n//               }\n//             ),\n//             score: action.payload.hitShip ? state.player_zero.score - 1 :  state.player_zero.score,\n//           },\n//           //when clicked on board 0, set ai played to true to enable state changes for respective square\n//           player_one : {\n//             ...state.player_one,\n//             aiPlayed: true\n//           }\n//         }\n//     }else{\n//         return {\n//         ...state,\n//         player_one:{\n//           ...state.player_one,\n//           clickedSquares : state.player_one.clickedSquares.concat(\n//             {\n//               x_coord: action.payload.x_coord,\n//               y_coord: action.payload.y_coord,\n//             }\n//           ),\n//           score: action.payload.hitShip ? state.player_one.score - 1 :  state.player_one.score\n//         }\n//       }\n//     }\n//   }\n// }\n//   if (action.type === RESTART) {\n//     //fetch the previous game type and set it\n//     let previousGameType = state.gameType.freePlay;\n//    let newState =  initialStateFunc();\n//    return {\n//     ...newState,\n//     gameType: {\n//       ...newState.gameType,\n//       freePlay: previousGameType\n//     }\n//   }\n//   }\n  if (action.type === BOARD_CLICK) {\n    let board;\n    if(action.payload.enemy){\n      board = state.ai_board;\n    }else{\n      board = state.user_board\n    }\n    let boardCopy = board.map(function(arr){\n      return arr.slice();\n    });\n    let squareCopy = { ...boardCopy[action.payload.row][action.payload.col] };\n    squareCopy.hit = action.payload.hit;\n    squareCopy.miss = action.payload.miss;\n    squareCopy.unselected = action.payload.unselected;\n    boardCopy[action.payload.row][action.payload.col] = squareCopy;\n    if(action.payload.enemy){\n      return {\n        ...state,\n        ai_board : boardCopy,\n        aiPlayed : false\n      }\n    }else{\n      return {\n        ...state,\n        user_board : boardCopy,\n        aiPlayed : true\n      }\n  }\n}\n\n  if(action.type === SET_GAME_TYPE){\n     return {\n     ...state,\n     freePlay : action.payload.gameType === \"normal\" ? false : true,\n     user_board: buildBoard(),\n     ai_board: buildBoard(),\n     aiPlayed: true\n     }\n    }\n  if (action.type === RESTART) {\n    let newUserBoard = []\n    let newAIBoard = []\n    newUserBoard = buildBoard()\n    newAIBoard = buildBoard()\n    return {\n      ...state,\n      freePlay: action.payload.isFreePlay,\n      user_board: newUserBoard,\n      ai_board: newAIBoard,\n    }\n  }\n   return state;\n};\n\n"]},"metadata":{},"sourceType":"module"}